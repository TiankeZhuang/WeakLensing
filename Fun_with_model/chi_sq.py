# -*- coding: utf-8 -*-
"""
Created on Fri Jan 15 12:32:57 2021

In this document:
1. "data" always refers to measurements of NG and NN correlation function 
generated by treecorr; 
2. "theory" always refers to theoretical predictions of NG and NN correllation 
function generated by ccl;
3. "model" always refers to 

@author: zhuan
"""

import matplotlib.pyplot as plt
import numpy as np
from scipy import interpolate
from scipy.linalg import kron
import scipy as sp

plt.rcdefaults()
plt.rcParams.update({'figure.dpi':100})
plt.rcParams.update({'figure.autolayout':'True'})
plt.rcParams.update({'font.size': 14})
plt.rcParams.update({'font.family': 'sans-serif'})
plt.rcParams.update({'mathtext.default':'regular'})
plt.rcParams.update({'mathtext.fontset':'stixsans'})
plt.rcParams.update({'axes.linewidth': 1.5})
plt.rcParams.update({'xtick.major.width': 1.25 })
plt.rcParams.update({'xtick.minor.size': 2.5})
plt.rcParams.update({'xtick.minor.width': 1.25 })
plt.rcParams.update({'ytick.major.size': 5})
plt.rcParams.update({'ytick.major.width': 1.25 })
plt.rcParams.update({'ytick.minor.size': 2.5})
plt.rcParams.update({'ytick.minor.width': 1.25 })
plt.rc('legend',**{'fontsize':'x-small'})
#plt.figure(1,figsize = [11.0, 8.5])
plt.rcParams.update({'xtick.direction':'in'})
plt.rcParams.update({'ytick.direction':'in'})
plt.rcParams.update({'xtick.top':'True'})
plt.rcParams.update({'ytick.right':'True'})
plt.rcParams.update({'axes.formatter.limits': (-2, 2)})
# My own adds to Carles' rcParams updates
#plt.rcParams.update({'lines.markersize': 8}) 6 is the default
plt.rcParams.update({'legend.framealpha': 1.0})
plt.rcParams.update({'legend.fancybox': 'False'})

#################### photo_z / i-band magnitude bins ###################

pz_ranges = np.array([0, 0.3, 0.6, 0.9, 1.2, 1.5, np.inf])
im_ranges = np.array([17, 18, 19, 20, 21, 22, 23, np.inf])
colorwheel = ['blue', 'red', 'green', 
              'orange', 'teal', 'purple', 
              'cyan', 'pink', 'olive']

########################## import data info ############################

ng_col_names = ['r_nom', 'meanr', 'meanlogr', 
                'gamT', 'gamX', 'sigma', 
                'weight', 'npairs']
ng_col_formats = ['f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8']

nn_col_names = ['r_nom', 'meanr', 'meanlogr', 
                'xi', 'sigma_xi', 
                'DD', 'RR', 'DR', 'npairs']
nn_col_formats = ['f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8', 'f8']

def data_path_builder(corr, data, pz_range):
    '''
    Obtain a list of paths of a specific type for a given pz_range

    Parameters
    ----------
    corr : str
        'NG', 'NN'
    data : str
        'main', 'cor', 'cov'
    pz_range : arr
        Section of "pz_ranges"

    Returns
    -------
    paths : list of str
        A list of all path names for data to be imported.

    '''
    paths = []
    for i in range(len(pz_range)):
        #if (pz_range[i]<np.max(pz_range)):
        if (data=='main'):
            path = 'Result/{}_data/{:.1f}<zl<{:.1f}'.format(corr, 
                                                            pz_range[i], 
                                                            pz_range[i]+0.3)
            paths.append(path)
        else:
            path = 'Result/{}_data/{}_{:.1f}<zl<{:.1f}'.format(corr, 
                                                               data, 
                                                               pz_range[i], 
                                                               pz_range[i]+0.3)
            paths.append(path)
    return paths

def theo_path_builder(corr, prpt, pz_range):
    '''
    Obtain a list of paths of a specific type for a given pz_range

    Parameters
    ----------
    corr : str
        'NG', 'NN'
    prpt : str
        'theta', 'xi'
    pz_range : arr
        Section of "pz_ranges"

    Returns
    -------
    paths : list of str
        A list of all path names for theory prediction to be imported.

    '''
    paths = []
    for i in range(len(pz_range)):
        path = "Result/{}_model/{}_{:.1f}<zl<{:.1f}".format(corr, 
                                                            prpt, 
                                                            pz_range[i], 
                                                            pz_range[i]+0.3)
        paths.append(path)
    return paths

data_ng_paths = data_path_builder('NG', 'main', pz_ranges[1:-3])
data_nn_paths = data_path_builder('NN', 'main', pz_ranges[1:-2])

data_ng_cov_paths = data_path_builder('NG', 'cov', pz_ranges[1:-3])
data_nn_cov_paths = data_path_builder('NN', 'cov', pz_ranges[1:-2])

theo_ng_theta_paths = theo_path_builder('NG', 'theta', pz_ranges[1:-3])
theo_nn_theta_paths = theo_path_builder('NN', 'theta', pz_ranges[1:-2])

theo_ng_xi_paths = theo_path_builder('NG', 'xi', pz_ranges[1:-3])
theo_nn_xi_paths = theo_path_builder('NN', 'xi', pz_ranges[1:-2])

##################### Import Data / Theory Prediction ####################

def cov_diag(cov):
    '''
    Generate matrix with all entry but diagonal element being 0

    Parameters
    ----------
    cov : n*n arr
        Full covariance matrix

    Returns
    -------
    cov_new : n*n arr
        Covariance matrix with all elements but diagonal being zero

    '''
    diag = np.diag(cov)
    shape = cov.shape
    cov_new = np.zeros(shape)
    np.fill_diagonal(cov_new, diag)
    return cov_new

def get_data(corr, ind, cov_prpt="full"):
    '''
    read data content from a path in list of paths 
    Parameters
    ----------
    corr : str
        'NG', 'NN'
    ind : int
        index in the list of paths.
    cov_prpt : str
        'full', 'diag'

    Returns
    -------
    r : arr
        radial reparation in arcmin.
    xi : arr
    sig : arr
    cov : arr

    '''

    if (corr == 'NG'):
        data = np.loadtxt(data_ng_paths[ind], 
                          dtype={'names': ng_col_names,
                                 'formats': ng_col_formats})
        r = np.exp(data['meanlogr'])
        xi = data['gamT']*(-1)
        sig = data['sigma']
        cov = np.loadtxt(data_ng_cov_paths[ind])
        
    if (corr == 'NN'):
        data = np.loadtxt(data_nn_paths[ind], 
                          dtype={'names': nn_col_names,
                                 'formats': nn_col_formats})
        r = np.exp(data['meanlogr'])
        xi = data['xi']
        sig = data['sigma_xi']
        cov = np.loadtxt(data_nn_cov_paths[ind])
    
    if (cov_prpt == "diag"):
        cov = cov_diag(cov)
    
    return r, xi, sig, cov

def get_theo(corr, ind):
    '''
    read theo content from a path in list of paths
    Parameters
    ----------
    corr : str
        'NG', 'NN'
    ind : int
        index in the list of paths.

    Returns
    -------
    theta_arcmin : TYPE
        DESCRIPTION.
    xi : TYPE
        DESCRIPTION.

    '''
    
    if (corr == 'NG'):
        theta_arcmin = np.loadtxt(theo_ng_theta_paths[ind])*60
        xi = np.loadtxt(theo_ng_xi_paths[ind])
    if (corr == 'NN'):
        theta_arcmin = np.loadtxt(theo_nn_theta_paths[ind])*60
        xi = np.loadtxt(theo_nn_xi_paths[ind])
    return theta_arcmin, xi

def get_chi_sq(data, model, cov):
    '''
    Get chi_sq from xi values of data and xi values of model

    Parameters
    ----------
    data : arr
        xi values of measured data.
    model : arr
        xi values of interpolated theory.
    cov : n*n arr
        full covariance matrix.

    Returns
    -------
    int
        chi_sq value.

    '''
    #Feed interpolated model
    return (data-model).T@sp.linalg.inv(cov)@(data-model)

def plot_chi_sq(ax, b, chi_sqs, label, colors):
    ax.plot(b, chi_sqs, colors, label=label)
    ax.set_xlabel(r'b')
    ax.set_ylabel(r'$\chi^2(b)$')
    ax.set_yscale('log')
    return

def get_chi_sq_plots(corr, pz_range, cov_prpt):
    '''
    Get chi_sq plot for NG corr in a certain pz_range

    Parameters
    ----------
    corr : str
        'NG', 'NN'
    pz_range : arr
        Segment of pz_ranges.
    cov_prpt : str
        'full', 'diag'

    Returns
    -------
    min_b : int 
        Min value of galaxy bias.
    min_chi : int
        Min value of chi.

    '''
    b = np.linspace(0, 4, 500)
    fig, ax = plt.subplots(1, 1)
    min_b = np.ones(len(pz_range))
    min_chi = np.ones(len(pz_range))
    for i in range(len(pz_range)):
        label = '{:.1f}<z_l<{:.1f}'.format(pz_range[i], pz_range[i]+0.3)
        r_data, xi_data, xi_sig, cov = get_data(corr, i, cov_prpt=cov_prpt)
        r_theo, xi_theo = get_theo(corr, i)
        f = interpolate.interp1d(r_theo, xi_theo)
        xi_theo_interp = f(r_data)
        if (corr == 'NG'):
            xi_model_mat = b[:,None]@xi_theo_interp[:,None].T
        elif (corr == 'NN'):
            xi_model_mat = (b**2)[:,None]@xi_theo_interp[:,None].T
        chi_sqs = np.ones(len(b))
        for j in range(len(b)):
            xi_model = xi_model_mat[j]
            chi_sq = get_chi_sq(xi_data, xi_model, cov)
            chi_sqs[j] = chi_sq
        plot_chi_sq(ax, b, chi_sqs, label, colorwheel[i])
        min_chi[i] = np.min(chi_sqs)
        min_b[i] = b[chi_sqs == np.min(chi_sqs)]
    ax.legend()
    ax.set_title(r'$\chi^2$ fitting for {} Correlation Function'.format(corr))
    return min_b, min_chi


def plot_xi(fig_type, ax, r, xi, label, colors, sig=0):
    '''
    Plot (log-log) r vs. xi with error bar.

    Parameters
    ----------
    fig_type : str
        'scatter', 'plot'
    ax : TYPE
        DESCRIPTION.
    r : arr
    xi : arr
    label : list of strings
        Legend label.
    color : str
    sig : arr, optional
        Error bar. The default is 0.

    Returns
    -------
    None.

    '''
    if (fig_type == 'scatter'):
        ax.scatter(r, xi, color=colors, label=label)
    elif (fig_type == 'plot'):
        ax.plot(r, xi, colors, label=label)
    ax.set_xlabel(r'$\theta$[arcmin]')
    ax.set_ylabel(r'$\xi(\theta)$')
    ax.set_xscale('log')
    ax.set_yscale('log', nonposy='clip')
    if (type(sig)!=int):
        ax.errorbar(r[xi>0], xi[xi>0], yerr=sig[xi>0], 
                    color='blue', lw=0.7, ls='')
    return

def plot_xi_mod(fig_type, ax, r, xi, label, colors, sig=0):
    '''
    Plot (log-lin) r vs. r*xi with error bar.

    Parameters
    ----------
    fig_type : str
        'scatter', 'plot'
    ax : TYPE
        DESCRIPTION.
    r : arr
    xi : arr
    label : list of strings
        Legend label.
    color : str
    sig : arr, optional
        Error bar. The default is 0.

    Returns
    -------
    None.

    '''
    if (fig_type == 'scatter'):
        ax.scatter(r, r*xi, color=colors, label=label)
    elif (fig_type == 'plot'):
        ax.plot(r, r*xi, colors, label=label)
    ax.set_xlabel(r'$\theta$[arcmin]')
    ax.set_ylabel(r'$\theta\times\xi$')
    ax.set_xscale('log')
    if (type(sig)!=int):
        ax.errorbar(r, r*xi, yerr=r*sig, 
                    color='blue', lw=0.7, ls='')
    return

def min_b_comp(corr, pz_range, min_b, cov_prpt):
    '''
    Generate comparison plot for data, theo, model,
    left panel theta vs. theta*xi, right panel theta vs. xi

    Parameters
    ----------
    corr : str
        'NG', 'NN'
    pz_range : arr
        Segment of pz_ranges.
    min_b : arr
        Generated through get_chi_sq.
    cov_prpt : str
        'full', 'diag'

    Returns
    -------
    None.

    '''
    fig, ax = plt.subplots(len(pz_range), 2, figsize=(10, 15))
    for i in range(len(pz_range)):
        b = min_b[i]
        title = '{:.1f}<z_l<{:.1f}, b={:.2f}'.format(pz_range[i], pz_range[i]+0.3, b)
        ax[i][0].set_title(title)
        ax[i][1].set_title(title)
        r_data, xi_data, xi_sig, cov = get_data(corr, i, cov_prpt=cov_prpt)
        r_theo, xi_theo = get_theo(corr, i)
        f = interpolate.interp1d(r_theo, xi_theo)
        xi_theo_interp = f(r_data)
        if (corr == 'NG'):
            xi_model = b*xi_theo_interp
        elif (corr == 'NN'):
            xi_model = (b**2)*xi_theo_interp
        
        plot_xi_mod('scatter', ax[i][0], r_data, xi_data, 'Data', 'blue', xi_sig)
        plot_xi_mod('plot', ax[i][0], r_theo, xi_theo, 'Theory', 'red')
        plot_xi_mod('plot', ax[i][0], r_data, xi_model, 'Model', 'green')
        
        plot_xi('scatter', ax[i][1], r_data, xi_data, 'Data', 'blue', xi_sig)
        plot_xi('plot', ax[i][1], r_theo, xi_theo, 'Theory', 'red')
        plot_xi('plot', ax[i][1], r_data, xi_model, 'Model', 'green')
        ax[i][1].legend()
    return

def pop(corr, pz_range, cov_prpt, fig_size):
    '''
    Consecutively remove lower theta terms to reduce chi_sq.

    Parameters
    ----------
    corr : str
        'NG', 'NN'
    pz_range : arr
        Segment of pz_ranges.
    cov_prpt : str
        'full', 'diag'

    Returns
    -------
    min_b : arr 
        Min values of galaxy bias after each pop.
    min_chi : arr
        Min values of chi_sq after each pop.

    '''
    b = np.linspace(0, 4, 500)
    fig, ax = plt.subplots(len(pz_range), 1, figsize=fig_size)
    min_b = np.ones(len(pz_range)*8).reshape(len(pz_range), 8)
    min_chi = np.ones(len(pz_range)*8).reshape(len(pz_range), 8)
    # for each pz bin
    for i in range(len(pz_range)):
        r_data, xi_data, xi_sig, cov = get_data(corr, i, cov_prpt=cov_prpt)
        r_theo, xi_theo = get_theo(corr, i)
        f = interpolate.interp1d(r_theo, xi_theo)
        xi_theo_interp = f(r_data)
        # for 
        for j in range(len(r_data)-2):
            if (corr == 'NG'):
                xi_model_mat = b[:,None]@xi_theo_interp[:,None].T
            elif (corr == 'NN'):
                xi_model_mat = (b**2)[:,None]@xi_theo_interp[:,None].T
            chi_sqs = np.ones(len(b))
            for k in range(len(b)):
                xi_model = xi_model_mat[k]
                chi_sq = get_chi_sq(xi_data[j:], xi_model[j:], cov[j:,j:])
                chi_sqs[k] = chi_sq
            min_chi[i][j] = np.min(chi_sqs)
            min_b[i][j] = b[chi_sqs == np.min(chi_sqs)]
            label = r'$\chi^2$={:.2f}, b={:.2f}'.format(min_chi[i][j], min_b[i][j])
            plot_chi_sq(ax[i], b, chi_sqs, label, colorwheel[j])
        title = r'{:.1f}<z_l<{:.1f}'.format(pz_range[i], pz_range[i]+0.3)
        ax[i].set_title(title)
        ax[i].legend()
    return min_b, min_chi

def min_b_comp_new(corr, pz_range, cov_prpt, r_min_pos, min_b, fig_size):
    '''
    Plot theta vs. xi, theta vs. theta*xi for the new b value. NG corr

    Parameters
    ----------
    corr : str
        'NG', 'NN'
    pz_range : arr
        Segment of pz_ranges.
    min_b : arr
        new b values that corresponds to minimum chi_sq.
    r_min_pos : arr
        position of first unpopped point.
    cov_prpt : str
        'full', 'diag'

    Returns
    -------
    None.

    '''
    fig, ax = plt.subplots(len(pz_range), 2, figsize=fig_size)
    for i in range(len(pz_range)):
        b = min_b[i]
        title = '{:.1f}<z_l<{:.1f}, b={:.2f}'.format(pz_range[i], pz_range[i]+0.3, b)
        ax[i][0].set_title(title)
        ax[i][1].set_title(title)
        r_data, xi_data, xi_sig, cov = get_data(corr, i, cov_prpt=cov_prpt)
        r_theo, xi_theo = get_theo(corr, i)
        f = interpolate.interp1d(r_theo, xi_theo)
        xi_theo_interp = f(r_data)
        if (corr == 'NG'):
            xi_model = b*xi_theo_interp
        elif (corr == 'NN'):
            xi_model = (b**2)*xi_theo_interp
        
        plot_xi_mod('scatter', ax[i][0], r_data, xi_data, 'Data', 'blue',  xi_sig)
        plot_xi_mod('plot', ax[i][0], r_theo, xi_theo, 'Theory', 'red')
        plot_xi_mod('plot', ax[i][0], r_data, xi_model, 'Model', 'green')
        ax[i][0].axvline(x=r_data[r_min_pos[i]])
        
        plot_xi('scatter', ax[i][1], r_data, xi_data, 'Data', 'blue', xi_sig)
        plot_xi('plot', ax[i][1], r_theo, xi_theo, 'Theory', 'red')
        plot_xi('plot', ax[i][1], r_data, xi_model, 'Model', 'green')
        ax[i][1].axvline(x=r_data[r_min_pos[i]])
        ax[i][1].legend()
    return